* Exercises
** Input
*** #1
    Using the FIELDWIDTHS variable (see Constant Size), write a program to read
    election data, where each record represents one voter’s votes. Come up with a
    way to define which columns are associated with each ballot item, and print the
    total votes, including abstentions, for each item.
***** Answer
      #+BEGIN_SRC awk :in-file data/election_data :results pp :exports both
        BEGIN  { FIELDWIDTHS = "18 9 15" }

        NR > 2 {
            if ($2 ~ "x") {
                gore++
            } else if ($3 ~ "x") {
                bush++
            } else {
                abstained++
            }
        }

        END { print "Bush:", bush, "Gore:", gore, "Abstained:", abstained }
      #+END_SRC

      #+RESULTS:
      : Bush: 9 Gore: 10 Abstained: 1

*** #2
    Plain Getline, presented a program to remove C-style comments (‘/* … */’) from
    the input. That program does not work if one comment ends on one line and
    another one starts later on the same line. That can be fixed by making one
    simple change. What is it?

***** Answer
      #+BEGIN_SRC awk :in-file data/tcdrain.c :results pp :exports both
      {
          while ((i = index($0, "/*")) != 0) {
              out = substr($0, 1, i - 1)  # leading part of the string
              rest = substr($0, i + 2)    # ... */ ...
              j = index(rest, "*/")       # is */ in trailing part?
              if (j > 0) {
                  rest = substr(rest, j + 2)  # remove comment
              } else {
                  while (j == 0) {
                      # get more text
                      if (getline <= 0) {
                          print("unexpected EOF or error:", ERRNO) > "/dev/stderr"
                          exit
                      }
                      # build up the line using string concatenation
                      rest = rest $0
                      j = index(rest, "*/")   # is */ in trailing part?
                      if (j != 0) {
                          rest = substr(rest, j + 2)
                          break
                      }
                  }
              }
              # build up the output line using string concatenation
              $0 = out rest
          }
          print $0
      }
      #+END_SRC

      #+RESULTS:
      #+begin_example

      #include <errno.h>
      #include <termios.h>

      int __set_errno(int n) { return n; }

      int __libc_tcdrain (int fd) {
        if (fd < 0) {
            __set_errno (EBADF);
            return -1;
          }
         __set_errno (ENOSYS);
        return -1;
      }
  #+end_example

** Output

*** #1
    Rewrite the program:
    #+BEGIN_SRC awk :in-file data/inventory-shipped :results pp :exports both
    BEGIN { print "Month Crates"; print "----- ------" }
    { print $1, "     ", $2 }
    #+END_SRC

    #+RESULTS:
    : Month Crates
    : ----- ------
    : Jan       13
    : Feb       15
    : Mar       15
    : Aug       11
    : Sep       25
    : Dec       6

    from Output Separators, by using a new value of OFS.

***** Answer
      #+BEGIN_SRC awk :in-file data/inventory-shipped :results pp :exports both
      BEGIN { print "Month Crates"; print "----- ------"; OFS="     " }
      { print $1, $2 }
      #+END_SRC

      #+RESULTS:
      : Month Crates
      : ----- ------
      : Jan     13
      : Feb     15
      : Mar     15
      : Aug     11
      : Sep     25
      : Dec     6
** Library
*** #1
    In Empty Files, we presented the ~zerofile.awk~ program, which made use of gawk’s
    =ARGIND= variable. Can this problem be solved without relying on =ARGIND=? If so,
    how?
***** ~zerofile.awk~
      #+BEGIN_SRC awk :in-file data/empty data/empty1 :results pp :exports both
      BEGIN { Argind = 0 }

      ARGIND > Argind + 1 {
          for (Argind++; Argind < ARGIND; Argind++)
              print(ARGV[Argind], Argind)
      }

      ARGIND != Argind { Argind = ARGIND }

      END {
          if (ARGIND > Argind)
              for (Argind++; Argind <= ARGIND; Argind++)
                  print(ARGV[Argind])
      }
      #+END_SRC

      #+RESULTS:
      : data/empty 1
      : data/empty1 2

***** Answer
      Use ~ENDFILE~ to run a function at the end of each file. You could match
      ~argc~/~argv~ as well if you wanted to determine the index of the filename
      argument.

      #+BEGIN_SRC awk :in-file data/empty data/empty1 :results pp :exports both
      ENDFILE { print(FILENAME) }
      #+END_SRC

      #+RESULTS:
      : data/empty
      : data/empty1
