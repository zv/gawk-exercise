* Gnu AWK Exercises
  [[https://www.gnu.org/software/gawk/manual/gawk.html#Print][The GNU Awk manual]] contains a number of exercises intended to help an
  aspiring =awk= wizard advance their skills.

  The manual itself doesn't contain any answers to these exercises and I haven't
  found any elsewhere. This repository provides those answer for those who are
  stuck or need quick review.

  These answers are composed in literate programming style which combines prose,
  source code and it's output into a single document.

  If you've found a cleaner or more didactic solution that /exclusively/ uses
  features presented prior to the section where that exercise appears, [[https://github.com/zv/gawk-exercise/issues][please
  submit a pull request!]]

** Exercises
*** Input
**** #1
     Using the FIELDWIDTHS variable (see Constant Size), write a program to read
     election data, where each record represents one voter’s votes. Come up with a
     way to define which columns are associated with each ballot item, and print the
     total votes, including abstentions, for each item.
****** Answer
       #+BEGIN_SRC awk :in-file data/election_data :results pp :exports both
         BEGIN  { FIELDWIDTHS = "18 9 15" }

         NR > 2 {
             if ($2 ~ "x") {
                 gore++
             } else if ($3 ~ "x") {
                 bush++
             } else {
                 abstained++
             }
         }

         END { print "Bush:", bush, "Gore:", gore, "Abstained:", abstained }
       #+END_SRC

       #+RESULTS:
       : Bush: 9 Gore: 10 Abstained: 1

**** #2
     Plain Getline, presented a program to remove C-style comments (‘/* … */’) from
     the input. That program does not work if one comment ends on one line and
     another one starts later on the same line. That can be fixed by making one
     simple change. What is it?

****** Answer
       #+BEGIN_SRC awk :in-file data/tcdrain.c :results pp :exports both
       {
           while ((i = index($0, "/*")) != 0) {
               out = substr($0, 1, i - 1)  # leading part of the string
               rest = substr($0, i + 2)    # ... */ ...
               j = index(rest, "*/")       # is */ in trailing part?
               if (j > 0) {
                   rest = substr(rest, j + 2)  # remove comment
               } else {
                   while (j == 0) {
                       # get more text
                       if (getline <= 0) {
                           print("unexpected EOF or error:", ERRNO) > "/dev/stderr"
                           exit
                       }
                       # build up the line using string concatenation
                       rest = rest $0
                       j = index(rest, "*/")   # is */ in trailing part?
                       if (j != 0) {
                           rest = substr(rest, j + 2)
                           break
                       }
                   }
               }
               # build up the output line using string concatenation
               $0 = out rest
           }
           print $0
       }
       #+END_SRC

       #+RESULTS:
       #+begin_example

       #include <errno.h>
       #include <termios.h>

       int __set_errno(int n) { return n; }

       int __libc_tcdrain (int fd) {
         if (fd < 0) {
             __set_errno (EBADF);
             return -1;
           }
          __set_errno (ENOSYS);
         return -1;
       }
   #+end_example

*** Output

**** #1
     Rewrite the program:
     #+BEGIN_SRC awk :in-file data/inventory-shipped :results pp :exports both
     BEGIN { print "Month Crates"; print "----- ------" }
     { print $1, "     ", $2 }
     #+END_SRC

     #+RESULTS:
     : Month Crates
     : ----- ------
     : Jan       13
     : Feb       15
     : Mar       15
     : Aug       11
     : Sep       25
     : Dec       6

     from Output Separators, by using a new value of OFS.

****** Answer
       #+BEGIN_SRC awk :in-file data/inventory-shipped :results pp :exports both
       BEGIN { print "Month Crates"; print "----- ------"; OFS="     " }
       { print $1, $2 }
       #+END_SRC

       #+RESULTS:
       : Month Crates
       : ----- ------
       : Jan     13
       : Feb     15
       : Mar     15
       : Aug     11
       : Sep     25
       : Dec     6
*** Library
**** #1
     In Empty Files, we presented the ~zerofile.awk~ program, which made use of gawk’s
     =ARGIND= variable. Can this problem be solved without relying on =ARGIND=? If so,
     how?
****** ~zerofile.awk~
       #+BEGIN_SRC awk :in-file data/empty data/empty1 :results pp :exports both
       BEGIN { Argind = 0 }

       ARGIND > Argind + 1 {
           for (Argind++; Argind < ARGIND; Argind++)
               print(ARGV[Argind], Argind)
       }

       ARGIND != Argind { Argind = ARGIND }

       END {
           if (ARGIND > Argind)
               for (Argind++; Argind <= ARGIND; Argind++)
                   print(ARGV[Argind])
       }
       #+END_SRC

       #+RESULTS:
       : data/empty 1
       : data/empty1 2

****** Answer
       Use ~ENDFILE~ to run a function at the end of each file. You could match
       ~argc~/~argv~ as well if you wanted to determine the index of the filename
       argument.

       #+BEGIN_SRC awk :in-file data/empty data/empty1 :results pp :exports both
       ENDFILE { print(FILENAME, ++argi) }
       #+END_SRC

       #+RESULTS:
       : data/empty 1
       : data/empty1 2
**** #2
     As a related challenge, revise that code to handle the case where an
     intervening value in ~ARGV~ is a variable assignment.

       #+BEGIN_SRC awk :cmd-line "--assign=nval=9" :in-file data/empty data/empty1 :results pp :exports both
       ENDFILE {
         if (argv[argi++] !~ /^[a-zA-Z_][a-zA-Z0-9_]*=.*/) {
             print(FILENAME, argi)
         }
       }
       #+END_SRC

       #+RESULTS:
       : data/empty 1
       : data/empty1 2
*** Programs
**** #1
     Rewrite cut.awk (see [[https://www.gnu.org/software/gawk/manual/gawk.html#Cut-Program][Cut Program]]) using ~split()~ with "" as the separator.
****** Answer
       #+BEGIN_SRC awk :in-file data/inventory-shipped :results pp :exports both
 # cut.awk --- implement cut in awk

 # Options:
 #    -f list     Cut fields
 #    -d c        Field delimiter character
 #    -c list     Cut characters
 #
 #    -s          Suppress lines without the delimiter
 #
 # Requires getopt() and join() library functions

 function usage()
 {
     print("usage: cut [-f list] [-d c] [-s] [files...]") > "/dev/stderr"
     print("usage: cut [-c list] [files...]") > "/dev/stderr"
     exit 1
 }

 BEGIN {
     FS = "\t"    # default
     OFS = FS
     while ((c = getopt(ARGC, ARGV, "sf:c:d:")) != -1) {
         if (c == "f") {
             by_fields = 1
             fieldlist = Optarg
         } else if (c == "c") {
             by_chars = 1
             fieldlist = Optarg
             OFS = ""
         } else if (c == "d") {
             if (length(Optarg) > 1) {
                 printf("cut: using first character of %s" \
                        " for delimiter\n", Optarg) > "/dev/stderr"
                 Optarg = substr(Optarg, 1, 1)
             }
             fs = FS = Optarg
             OFS = FS
             if (FS == " ")    # defeat awk semantics
                 FS = "[ ]"
         } else if (c == "s")
             suppress = 1
         else
             usage()
     }

     # Clear out options
     for (i = 1; i < Optind; i++)
         ARGV[i] = ""

     if (by_fields && by_chars)
         usage()

     if (by_fields == 0 && by_chars == 0)
         by_fields = 1    # default

     if (fieldlist == "") {
         print "cut: needs list for -c or -f" > "/dev/stderr"
         exit 1
     }

     if (by_fields)
         set_fieldlist()
     else
         set_charlist()
 }

 function set_fieldlist(n, m, i, j, k, f, g)
 {
     n = split(fieldlist, f, ",")
     j = 1    # index in flist
     for (i = 1; i <= n; i++) {
         if (index(f[i], "-") != 0) { # a range
             m = split(f[i], g, "-")
             if (m != 2 || g[1] >= g[2]) {
                 printf("cut: bad field list: %s\n",
                                   f[i]) > "/dev/stderr"
                 exit 1
             }
             for (k = g[1]; k <= g[2]; k++)
                 flist[j++] = k
         } else
             flist[j++] = f[i]
     }
     nfields = j - 1
 }

 function set_charlist(    field, i, j, f, g, n, m, t,
                           filler, last, len)
 {
     field = 1   # count total fields
     n = split(fieldlist, f, ",")
     j = 1       # index in flist
     for (i = 1; i <= n; i++) {
         if (index(f[i], "-") != 0) { # range
             m = split(f[i], g, "-")
             if (m != 2 || g[1] >= g[2]) {
                 printf("cut: bad character list: %s\n",
                                f[i]) > "/dev/stderr"
                 exit 1
             }
             len = g[2] - g[1] + 1
             if (g[1] > 1)  # compute length of filler
                 filler = g[1] - last - 1
             else
                 filler = 0
             if (filler)
                 t[field++] = filler
             t[field++] = len  # length of field
             last = g[2]
             flist[j++] = field - 1
         } else {
             if (f[i] > 1)
                 filler = f[i] - last - 1
             else
                 filler = 0
             if (filler)
                 t[field++] = filler
             t[field++] = 1
             last = f[i]
             flist[j++] = field - 1
         }
     }
     FIELDWIDTHS = join(t, 1, field - 1)
     nfields = j - 1
 }

 {
     if (by_fields && suppress && index($0, fs) == 0)
         next

     for (i = 1; i <= nfields; i++) {
         if ($flist[i] != "") {
             printf "%s", $flist[i]
             if (i < nfields && $flist[i+1] != "")
                 printf "%s", OFS
         }
     }
     print ""
 }

       #+END_SRC
